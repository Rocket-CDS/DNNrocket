<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="adminsettings.Text" xml:space="preserve">
    <value>Admin Settings</value>
  </data>
  <data name="appthemefolder.Help" xml:space="preserve">
    <value>The name of the AppTheme folder on the remote server.  This will be used for the template display and offer different functionality based on the selection.</value>
  </data>
  <data name="appthemefolder.Text" xml:space="preserve">
    <value>Remote AppTheme Folder</value>
  </data>
  <data name="appthemeversion.Help" xml:space="preserve">
    <value>The version of the AppTheme to be used.  The format is "0.0", if empty the lastest AppTheme version is used.</value>
  </data>
  <data name="appthemeversion.Text" xml:space="preserve">
    <value>AppTheme version</value>
  </data>
  <data name="dashboard.Text" xml:space="preserve">
    <value>Dashboard</value>
  </data>
  <data name="engineurl.Help" xml:space="preserve">
    <value>This should include the protocol, domain.  Do NOT include the parameters or path.</value>
  </data>
  <data name="engineurl.Text" xml:space="preserve">
    <value>Engine Domain URL</value>
  </data>
  <data name="remoteadminrelpath.Help" xml:space="preserve">
    <value>If entered an icon will appear on the module for users in the "RemoteAdmin" role,  this icon will allow the user to be redirected to the admin website.  Users redirected will need to login to the admin system.</value>
  </data>
  <data name="remoteadminrelpath.Text" xml:space="preserve">
    <value>Remote Admin Rel Path</value>
  </data>
  <data name="remotecmd.Help" xml:space="preserve">
    <value>Remote Command is the command that will be run on first load.</value>
  </data>
  <data name="remotecmd.Text" xml:space="preserve">
    <value>Remote Command</value>
  </data>
  <data name="remoteheadercmd.Help" xml:space="preserve">
    <value>A remote header html can be added to the page header, the remote header html needs an individual call to the required API.</value>
  </data>
  <data name="remoteheadercmd.Text" xml:space="preserve">
    <value>Remote Header Command</value>
  </data>
  <data name="remoteheadertemplate.Help" xml:space="preserve">
    <value>The name of the remote template that will be used to inject any page header data.</value>
  </data>
  <data name="remoteheadertemplate.Text" xml:space="preserve">
    <value>Remote Header Template</value>
  </data>
  <data name="remotekey.Help" xml:space="preserve">
    <value>Remote Key is passed to the remote engine to access a particular set of data.</value>
  </data>
  <data name="remotekey.Text" xml:space="preserve">
    <value>Remote Key</value>
  </data>
  <data name="remotesystemkey.Help" xml:space="preserve">
    <value>The remote system key of the system which the remote connection should use.</value>
  </data>
  <data name="remotesystemkey.Text" xml:space="preserve">
    <value>Remote SystemKey</value>
  </data>
  <data name="remotetemplate.Help" xml:space="preserve">
    <value>The name of the remote template that will be used to display content on this website.</value>
  </data>
  <data name="remotetemplate.Text" xml:space="preserve">
    <value>Remote Template</value>
  </data>
  <data name="securitykey.Help" xml:space="preserve">
    <value>The remote portal will have a list of security keys, this security key MUST be in the list on the remote server.  Otherwise the call will be rejected by the remote server.</value>
  </data>
  <data name="securitykey.Text" xml:space="preserve">
    <value>Remote Security Key</value>
  </data>
  <data name="urlkey.Help" xml:space="preserve">
    <value>The URL Key is taken from the URL paramater matching this parameter key.  The value will be placed into the Remote Key.  This offers the ability to access data via a url parameter.</value>
  </data>
  <data name="urlkey.Text" xml:space="preserve">
    <value>URL Key</value>
  </data>
  <data name="urlkeyactive.Text" xml:space="preserve">
    <value>Activate URL Key</value>
  </data>
</root>